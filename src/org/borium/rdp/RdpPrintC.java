package org.borium.rdp;

import static org.borium.rdp.CRT.*;
import static org.borium.rdp.RDP.*;
import static org.borium.rdp.RdpAux.*;
import static org.borium.rdp.Set.*;
import static org.borium.rdp.Symbol.*;
import static org.borium.rdp.Text.*;
import static org.borium.rdp.Text.TextMessageType.*;

import java.io.*;
import java.util.ArrayList;

import org.borium.rdp.RdpAux.*;

@SuppressWarnings("unused")
public class RdpPrintC extends RdpPrint
{
	public void printHeader(String headerfilename)
	{
		PrintStream headerfile = null;
		RdpTableList temp_table = rdp_dir_symbol_table;
		RdpData temp = (RdpData) tokens.getScope().nextSymbolInScope();
		String filenamebase = text_uppercase_string(text_extract_filename(rdp_sourcefilename));

		if (rdp_verbose.value())
		{
			text_message(TEXT_INFO, "Dumping header file to \'" + headerfilename + "\'\n");
		}

		if (headerfilename.charAt(0) == '-')
		{
			headerfile = System.out;
		}
		else
		{
			try
			{
				headerfile = new PrintStream(headerfilename);
			}
			catch (FileNotFoundException e)
			{
				e.printStackTrace();
			}
		}
		text_redirect(headerfile);
		text_printf("/*******************************************************************************\n" + "*\n"
				+ "* Header file generated by RDP on ");
		text_print_time();
		text_printf(" from " + text_force_filetype(rdp_sourcefilename, "bnf") + "\n" + "*\n"
				+ "*******************************************************************************/\n" + "#ifndef "
				+ filenamebase + "_H\n" + "#define " + filenamebase + "_H\n\n" + "#include \"arg.h\"\n"
				+ "#include \"graph.h\"\n" + "#include \"hist.h\"\n" + "#include \"memalloc.h\"\n"
				+ "#include \"scan.h\"\n" + "#include \"set.h\"\n" + "#include \"symbol.h\"\n"
				+ "#include \"textio.h\"\n\n");
		text_printf("\n/* Maximum number of passes */\n#define RDP_PASSES " + rdp_dir_passes + "\n");
		text_printf("\n/* Time and date stamp */\n#define RDP_STAMP \"Generated on ");
		text_print_time();
		text_printf(" and compiled on \" __DATE__ \" at \" __TIME__ \n");
		/* print token enumeration */
		boolean first = true;
		int count = 0;
		text_printf("\n/* Token enumeration */\nenum\n{\nRDP_TT_BOTTOM = SCAN_P_TOP");
		while (temp != null)
		{
			if (temp.kind == K_TOKEN || temp.kind == K_EXTENDED)
			{
				text_printf(",");
				if (count++ % 8 == 0)
				{
					text_printf("\n");
				}
				rdp_print_parser_production_name(temp);
				if (first)
				{
					text_printf(" = SCAN_P_TOP");
					first = false;
				}
			}
			temp = (RdpData) temp.nextSymbolInScope();
		}
		text_printf(",\nRDP_TT_TOP\n};\n\n");
		/* print declaration for tree datatype */
		text_printf("/* Tree data types */\n\n" + "typedef struct rdp_tree_node_data_struct\n{\n  SCAN_DATA\n  "
				+ rdp_dir_tree_node_fields + "\n} rdp_tree_node_data;\n"
				+ "typedef struct rdp_tree_edge_data_struct\n{\n  int rdp_edge_kind;\n  " + rdp_dir_tree_edge_fields
				+ "\n} rdp_tree_edge_data;\n\n");
		/* print declarations for symbol tables */
		text_printf("/* Symbol table support */\n");
		while (temp_table != null)
		{
			String data_fields = temp_table.data_fields;
			text_printf("typedef struct " + temp_table.name + "_data_node\n{\n");
			for (char ch : data_fields.toCharArray())
			{
				if (ch != '\r')
				{
					text_printf("" + ch);
				}
			}
			text_printf("\n} " + temp_table.name + "_data;\n");
			text_printf("extern void * " + temp_table.name + ";\n");
			text_printf("extern " + temp_table.name + "_data * " + temp_table.name + "_temp;\n");
			text_printf("#define " + temp_table.name + "_cast(x) ((" + temp_table.name + "_data *)x)\n\n");
			temp_table = temp_table.next;
		}
		/* print start production prototype */
		text_printf("/* Parser start production */\n");
		text_printf(rdp_start_prod.return_type);
		for (count = 0; count < rdp_start_prod.return_type_stars; count++)
		{
			text_printf("*");
		}
		text_printf(" " + text_get_string(rdp_start_prod.id));
		rdp_print_parser_param_list(null, rdp_start_prod.params, 1, 0);
		text_printf(";\n\n");
		text_printf("\n\n#endif\n\n/* End of " + text_force_filetype(headerfilename, "h") + " */\n");
		text_redirect(System.out);
		if (headerfile != System.out)
			headerfile.close();
	}

	public void printParser(String outputfilename, SymbolScopeData base)
	{
		if (rdp_verbose.value())
		{
			text_message(TEXT_INFO, "Dumping parser file to \'" + outputfilename + "\'\n");
		}
		PrintStream parserfile = null;
		if (outputfilename.charAt(0) == '-')
		{
			parserfile = System.out;
		}
		else
		{
			try
			{
				parserfile = new PrintStream(outputfilename);
			}
			catch (FileNotFoundException e)
			{
				e.printStackTrace();
			}
		}
		text_redirect(parserfile);
		/* print main file header */
		text_printf("/*******************************************************************************\n" + "*\n"
				+ "* Parser generated by RDP on ");
		text_print_time();
		text_printf(" from " + text_force_filetype(rdp_sourcefilename, "bnf") + "\n" + "*\n"
				+ "*******************************************************************************/\n"
				+ "#include <time.h>\n");
		if (rdp_dir_include != null)
		{
			rdp_print_parser_include_line(rdp_dir_include);
		}
		if (outputfilename.charAt(0) != '-')
		{
			text_printf("#include \"" + text_force_filetype(outputfilename, "h") + "\"\n");
		}
		text_printf("\nchar\n" + "  *rdp_sourcefilename,          /* current source file name */\n"
				+ "  **rdp_sourcefilenames,        /* array of source file names */\n" + "  *rdp_outputfilename = \""
				+ rdp_dir_output_file + "\";         /* output file name */\n\n"
				+ "int\n  rdp_symbol_echo = 0,                 /* symbol echo flag */\n"
				+ "  rdp_verbose = 0,                     /* verbosity flag */\n"
				+ "  rdp_sourcefilenumber,                /* Source file counter */\n"
				+ "  rdp_pass;                            /* pass number */\n\n"
				+ "int rdp_error_return = 0;              /* return value for main routine */\n\n"
				+ "char *rdp_tokens = ");

		for (int token_count = 0; token_count < rdp_token_count; token_count++)
		{
			text_printf("\"" + rdp_token_string[token_count] + "\\0\" ");
			if (token_count % 8 == 0)
			{
				text_printf("\n");
			}
		}
		text_printf(";\n\n");
		RdpTableList temp_table = rdp_dir_symbol_table;
		while (temp_table != null)
		{
			text_printf(temp_table.name + "_data * " + temp_table.name + "_temp = NULL;\n");
			text_printf("void* " + temp_table.name + " = NULL;\n");
			temp_table = temp_table.next;
		}
		/* print tree update flag and routine */
		if (rdp_dir_tree != 0)
		{
			text_printf("\n/* Tree update function for noterminal nodes */\n" + "static int rdp_tree_update = 0;\n\n"
					+ "rdp_tree_node_data* rdp_tree_last_child;\n\n"
					+ "rdp_tree_node_data* rdp_add_node(char* id, rdp_tree_node_data* rdp_tree)\n" + "{\n"
					+ "  if (rdp_tree_update)\n" + "  {\n"
					+ "     rdp_tree_node_data *node  = (rdp_tree_node_data*) graph_insert_node(sizeof(rdp_tree_node_data), rdp_tree);\n"
					+ "     if (id != NULL)\n" + "       node->id = id;\n" + "     else\n"
					+ "       memcpy(node, text_scan_data, sizeof(scan_data));\n" + "       return node;\n" + "  }\n"
					+ "  else\n" + "    return NULL;\n" + "}\n\n"
					+ "rdp_tree_node_data* rdp_add_child(char* id, rdp_tree_node_data* rdp_tree)\n" + "{\n"
					+ "  if (rdp_tree_update)\n" + "  {\n"
					+ "    rdp_tree_last_child = (rdp_tree_node_data*) graph_insert_node(sizeof(rdp_tree_node_data), rdp_tree);\n"
					+ "      if (id != NULL)\n" + "        rdp_tree_last_child->id = id;\n" + "    else\n"
					+ "      memcpy(rdp_tree_last_child, text_scan_data, sizeof(scan_data));\n\n"
					+ "    ((rdp_tree_edge_data*) graph_insert_edge_after_final(sizeof(rdp_tree_edge_data), rdp_tree_last_child, rdp_tree))->rdp_edge_kind = 1;\n"
					+ "    return rdp_tree_last_child;\n" + "  }\n" + "  else\n" + "    return NULL;\n" + "}\n\n" +

					"rdp_tree_node_data* rdp_add_parent(char* id, rdp_tree_node_data* rdp_tree)\n" + "{\n"
					+ "  if (rdp_tree_update)\n" + "  {\n"
					+ "    rdp_tree_node_data *parent = (rdp_tree_node_data*) graph_insert_node_parent(sizeof(rdp_tree_node_data), sizeof(rdp_tree_edge_data), rdp_tree);\n"
					+ "    if (id != NULL)\n" + "      parent->id = id;\n" + "    else\n"
					+ "      memcpy(parent, text_scan_data, sizeof(scan_data));\n\n"
					+ "    ((rdp_tree_edge_data*) graph_next_out_edge(parent))->rdp_edge_kind = 1;\n\n"
					+ "    return parent;\n" + "  }\n" + "  else\n" + "    return NULL;\n" + "}\n\n");
		}

		/* print load keyword function */
		text_printf("\n/* Load keywords */\nstatic void rdp_load_keywords(void)\n{\n");
		RdpData temp = (RdpData) tokens.getScope().nextSymbolInScope();
		while (temp != null)
		{
			if (temp.kind == K_TOKEN || temp.kind == K_EXTENDED)
			{
				text_printf("  scan_load_keyword(\"");
				rdp_print_parser_string(text_get_string(temp.id));
				text_printf("\", ");

				if (temp.close != null)
				{
					text_printf("\"");
					rdp_print_parser_string(temp.close);
					text_printf("\", ");
				}
				else
				{
					text_printf("NULL, ");
				}
				text_printf(text_get_string(temp.token_enum) + ", ");
				text_printf(temp.extended_enum);
				text_printf(");\n");
			}
			temp = (RdpData) temp.nextSymbolInScope();
		}
		text_printf("}\n");

		/* print set declaration */
		text_printf("\n/* Set declarations */\n\n");
		temp = (RdpData) base.nextSymbolInScope();
		while (temp != null)
		{
			if (rdp_production_set.includes(temp.kind) && temp.code_only == 0)
			{
				if (temp.first_cardinality > 1)
				{
					text_printf("  set_ " + text_get_string(temp.id) + "_first = SET_NULL;\n");
				}

				if (temp.kind == K_PRIMARY)
				{
					text_printf("  set_ " + text_get_string(temp.id) + "_stop = SET_NULL;\n");
				}
			}
			temp = (RdpData) temp.nextSymbolInScope();
		}

		text_printf("\n/* Initialise sets */\n\nstatic void rdp_set_initialise(void)\n{\n");
		temp = (RdpData) base.nextSymbolInScope();
		while (temp != null)
		{
			if (rdp_production_set.includes(temp.kind) && temp.code_only == 0)
			{
				if (temp.first_cardinality > 1)
				{
					text_printf("  set_assign_list(&" + text_get_string(temp.id) + "_first, ");
					temp.first.print(rdp_enum_string, 78);
					text_printf(", SET_END);\n");
				}

				if (temp.kind == K_PRIMARY)
				{
					text_printf("  set_assign_list(&" + text_get_string(temp.id) + "_stop, ");
					temp.follow.print(rdp_enum_string, 78);
					text_printf(",SET_END);\n");
				}
			}
			temp = (RdpData) temp.nextSymbolInScope();
		}
		text_printf("}\n");

		/* print forward declarations */
		text_printf("\n/* Parser forward declarations and macros */\n");
		temp = (RdpData) base.nextSymbolInScope();
		while (temp != null)
		{
			if (temp.kind == K_PRIMARY && temp.call_count > 0)
			{
				int count;

				if (temp.code_only != 0)
				{
					text_printf("#define " + text_get_string(temp.id));
					if (temp.params != null)
					{
						rdp_print_parser_param_list(null, temp.params, 0, 0);
					}
					text_printf(" ");
					rdp_print_parser_alternate(temp, temp);
				}
				else
				{
					if (temp != rdp_start_prod)
					{
						text_printf("static ");
					}

					text_printf(temp.return_type);

					for (count = 0; count < temp.return_type_stars; count++)
					{
						text_printf("*");
					}
					text_printf(" " + text_get_string(temp.id));

					rdp_print_parser_param_list(null, temp.params, 1, 0);

					text_printf(";\n");
				}
			}
			temp = (RdpData) temp.nextSymbolInScope();
		}

		/* print global string */
		if (rdp_dir_global != null)
		{
			text_printf("\n/* Global directive code */\n" + rdp_dir_global + "\n");
		}

		/* print parser definitions */
		rdp_print_parser_primaries(base);

		/* print main line routine */
		text_printf("int main(int argc, char *argv[])\n" + "{\n"
				+ "  clock_t rdp_finish_time, rdp_start_time = clock();\n" + "  int\n"
				+ "    rdp_symbol_statistics = 0,    /* show symbol_ table statistics flag */\n"
				+ "    rdp_line_echo_all = 0,        /* make a listing on all passes flag */\n"
				+ "    rdp_filter = 0,               /* filter flag */\n"
				+ "    rdp_line_echo = 0,            /* make listing flag */\n\n"
				+ "    rdp_lexicalise = 0;            /* print lexicalised output flag */\n\n"
				+ "  unsigned long rdp_textsize = " + rdp_dir_text_size + "l;   /* size of scanner text array */\n\n"
				+ "  unsigned long rdp_tabwidth = " + rdp_dir_tab_width + "l;   /* tab expansion width */\n\n");

		text_printf("  char* rdp_vcg_filename = NULL;      /* filename for -V option */\n\n");

		if (rdp_dir_tree != 0)
		{
			text_printf(
					"  rdp_tree_node_data* rdp_tree = (rdp_tree_node_data*) graph_insert_graph(\"RDP derivation tree\");  /* hook for derivation tree */\n"
							+ "  rdp_tree_node_data* rdp_tree_root;\n\n");
		}

		/* print help building code */
		text_printf("  arg_message(\"" + rdp_dir_title + "\\n\" RDP_STAMP \"\\n\\n\"");
		text_printf("\"Usage: " + outputfilename.substring(0, outputfilename.lastIndexOf('.')) + " [options] source");

		if (rdp_dir_suffix.length() != 0)
		{
			text_printf("[." + rdp_dir_suffix + "]");
		}
		text_printf("\");\n\n");

		if (rdp_dir_args != null)
		{
			rdp_print_parser_args(rdp_dir_args);
		}

		text_printf("\n  rdp_sourcefilenames = arg_process(argc, argv);\n\n");

		text_printf("  /* Fix up filetypes */\n"
				+ "  for (rdp_sourcefilenumber = 0; rdp_sourcefilenames[rdp_sourcefilenumber] != NULL; rdp_sourcefilenumber++)\n"
				+ "    rdp_sourcefilenames[rdp_sourcefilenumber] = text_default_filetype(rdp_sourcefilenames[rdp_sourcefilenumber], \""
				+ rdp_dir_suffix + "\");\n\n");

		text_printf("  if (rdp_filter)\n" + "  {\n" + "    rdp_sourcefilenames[0] = \"-\";\n"
				+ "    rdp_outputfilename = \"-\";\n"
				+ "    rdp_sourcefilenames[1] = NULL;     /* make sure no further filenames are taken from the array */\n\n"
				+ "  }\n");

		text_printf("  if ((rdp_sourcefilename = rdp_sourcefilenames[0]) == NULL)\n"
				+ "     arg_help(\"no source files specified\");\n\n");

		if (rdp_dir_multiple_source_files == 0)
		{
			text_printf("  if (rdp_sourcefilenames[1] != NULL)\n"
					+ "    text_message(TEXT_FATAL, \"multiple source files not allowed\\n\");\n");
		}

		text_printf("  text_init(rdp_textsize, " + rdp_dir_max_errors + ", " + rdp_dir_max_warnings
				+ ", (int) rdp_tabwidth);\n" + "  scan_init(" + rdp_dir_case_insensitive + ", "
				+ rdp_dir_newline_visible + ", " + rdp_dir_show_skips
				+ ", rdp_symbol_echo, rdp_tokens);\n  if (rdp_lexicalise)\n    scan_lexicalise();\n");

		if (rdp_dir_retain_comments != 0)
		{
			text_printf("  scan_retain_comments(1);\n");
		}

		/* Initialise any symbol tables */
		temp_table = rdp_dir_symbol_table;
		while (temp_table != null)
		{
			text_printf("  " + temp_table.name + " = symbol_new_table(\"" + temp_table.name + "\", " + temp_table.size
					+ ", " + temp_table.prime + ", " + temp_table.compare + ", " + temp_table.hash + ", "
					+ temp_table.print + ");\n");
			temp_table = temp_table.next;
		}

		text_printf("  rdp_set_initialise();\n" + "  rdp_load_keywords();\n");

		if (rdp_dir_pre_parse != null)
		{
			text_printf("  " + rdp_dir_pre_parse + "\n");
		}

		text_printf(
				"  if (rdp_verbose)\n" + "     text_printf(\"\\n" + rdp_dir_title + "\\n\" RDP_STAMP \"\\n\\n\");\n");

		text_printf("  for (rdp_pass = 1; " + (rdp_dir_passes == 0 ? "" : "rdp_pass <= RDP_PASSES")
				+ "; rdp_pass++)\n  {\n");

		if (rdp_dir_tree != 0)
		{
			text_printf("    rdp_tree_update = rdp_pass == RDP_PASSES;\n");
		}

		text_printf("    text_echo(rdp_line_echo_all || (rdp_line_echo && rdp_pass == RDP_PASSES));\n\n"
				+ "    for (rdp_sourcefilenumber = 0; (rdp_sourcefilename = rdp_sourcefilenames[rdp_sourcefilenumber]) != NULL; rdp_sourcefilenumber++)\n"
				+ "    {\n" + "      if (text_open(rdp_sourcefilename) == NULL)\n"
				+ "        arg_help(\"unable to open source file\");\n\n" + "      text_get_char();\n"
				+ "      scan_();\n\n");

		text_printf("      " + text_get_string(rdp_start_prod.id));

		rdp_print_parser_param_list(text_get_string(rdp_start_prod.id), rdp_start_prod.params, 0, 1);

		text_printf(";            /* call parser at top level */\n" + "      if (text_total_errors() != 0)\n"
				+ "        text_message(TEXT_FATAL, \"error%s detected in source file '" + "rdparser"
				+ "'\\n\", text_total_errors() == 1 ? \"\" : \"s\", rdp_sourcefilename);   /* crash quietly */\n");

		if (rdp_dir_tree != 0 && rdp_dir_epsilon_tree == 0)
		{
			text_printf("      graph_epsilon_prune_rdp_tree(rdp_tree_root, sizeof(rdp_tree_edge_data));\n");
		}

		text_printf("    }\n" + "  }\n\n"
				+ "  rdp_sourcefilename = rdp_sourcefilenames[0];     /* Reset filename to first file in the list */\n\n");

		if (rdp_dir_tree != 0)
		{
			text_printf("  graph_set_root(rdp_tree, rdp_tree_root);\n");

			text_printf("  if (rdp_vcg_filename != NULL)\n" + "  {\n" + "    FILE *rdp_vcg_file;\n\n"
					+ "    if (*rdp_vcg_filename == \'\\0\')   /* No filename supplied */\n"
					+ "      rdp_vcg_filename = \"rdparser\";\n"
					+ "    rdp_vcg_file = fopen((rdp_vcg_filename = text_default_filetype(rdp_vcg_filename, \"vcg\")), \"w\");\n\n"
					+ "    if (rdp_vcg_file == NULL)\n"
					+ "      text_message(TEXT_FATAL, \"unable to open VCG file \'%s\' for write\\n\", rdp_vcg_filename);\n\n"
					+ "    if (rdp_verbose)\n"
					+ "      text_message(TEXT_INFO, \"Dumping derivation tree to VCG file \'%s\'\\n\", rdp_vcg_filename);\n\n"
					+ "    text_redirect(rdp_vcg_file);\n"
					+ "    graph_vcg(rdp_tree, NULL, scan_vcg_print_node, scan_vcg_print_edge);\n"
					+ "    text_redirect(stdout);\n" + "    fclose(rdp_vcg_file);\n" + "  }\n\n");
		}

		if (rdp_dir_post_parse != null)
		{
			text_printf("  " + rdp_dir_post_parse + "\n");
		}

		text_printf("  if (rdp_symbol_statistics)\n" + "  {\n" + "    symbol_print_all_table_statistics(11);\n"
				+ "    symbol_print_all_table();\n\n" + "  }\n" + "  text_print_total_errors();\n"
				+ "  if (rdp_verbose)\n" + "  {\n" + "    rdp_finish_time = clock();\n"
				+ "    text_message(TEXT_INFO, \"%.3f CPU seconds used\\n\", ((double) (rdp_finish_time-rdp_start_time)) / CLOCKS_PER_SEC);\n"
				+ "  }\n");

		text_printf("  return rdp_error_return;\n}\n");

		text_printf("\n/* End of " + text_force_filetype(outputfilename, "c") + " */\n");

		text_redirect(System.out);
		if (parserfile != System.out)
			parserfile.close();
	}

	public void rdp_dump_extended(SymbolScopeData base)
	{
		RdpData temp = (RdpData) base.nextSymbolInScope();

		if (rdp_verbose.value())
		{
			text_printf("\n Expanded EBNF listing\n\n");
		}
		while (temp != null)
		{
			RdpList list = temp.list;
			int k = temp.kind;

			if (k != K_CODE && k != K_STRING && k != K_INTEGER && k != K_REAL)
			{
				text_printf(" ");
				rdp_print_parser_production_name(temp);

				rdp_print_parser_param_list(null, temp.params, 1, 0);

				text_printf(":" + temp.return_type);
				for (int count = 0; count < temp.return_type_stars; count++)
				{
					text_printf("*");
				}
				text_printf(" ::= ");

				if (k == K_TOKEN)
				{
					text_printf("\'" + text_get_string(temp.id) + "\'");
				}
				else
				{
					if (k == K_LIST)
					{
						if (temp.lo == 0 && temp.hi == 0 && temp.supplementary_token == null)
						{
							text_printf("{ ");
						}
						else if (temp.lo == 0 && temp.hi == 1 && temp.supplementary_token == null)
						{
							text_printf("[ ");
						}
						else if (temp.lo == 1 && temp.hi == 0 && temp.supplementary_token == null)
						{
							text_printf("< ");
						}
						else
						{
							text_printf("( ");
						}
					}
					while (list != null)
					{
						rdp_print_parser_production_name(list.production);
						rdp_print_parser_param_list(null, list.actuals, 0, 0);

						if (list.return_name != null)
						{
							text_printf(":" + list.return_name);
						}

						text_printf(" ");
						list = list.next;
						if (k != K_SEQUENCE && list != null)
						{
							text_printf("| ");
						}
					}

					if (k == K_LIST)
					{
						if (temp.lo == 0 && temp.hi == 0 && temp.supplementary_token == null)
						{
							text_printf("}");
						}
						else if (temp.lo == 0 && temp.hi == 1 && temp.supplementary_token == null)
						{
							text_printf("]");
						}
						else if (temp.lo == 1 && temp.hi == 0 && temp.supplementary_token == null)
						{
							text_printf(">");
						}
						else if (temp.lo == 1 && temp.hi == 1 && temp.supplementary_token == null)
						{
							text_printf(")");
						}
						else
						{
							text_printf(")" + temp.lo + "@" + temp.hi);
							if (temp.supplementary_token != null)
							{
								text_printf(" \'" + text_get_string(temp.supplementary_token.id) + "\'");
							}
							else
							{
								text_printf(" #");
							}
						}
					}
				}

				text_printf(".\n");

				text_printf(" First set is {" + (temp.contains_null ? "(NULL) " : ""));
				temp.first.print(rdp_token_string, 78);
				text_printf("}\n");

				text_printf(" Stop set is {");
				temp.follow.print(rdp_token_string, 78);
				text_printf("}\n");

				if (temp.call_count == 1)
				{
					text_printf(" Production is called once\n\n");
				}
				else
				{
					text_printf(" Production is called " + temp.call_count + " times\n\n");
				}
			}

			temp = (RdpData) temp.nextSymbolInScope();
		}
	}

	private void rdp_print_locals(RdpData base, ArrayList<String> localsList)
	{
		if (!rdp_production_set.includes(base.kind))
		{
			return;
		}
		RdpList list = base.list;
		while (list != null)
		{
			if (list.production.kind != K_PRIMARY)
			{
				rdp_print_locals(list.production, localsList);
			}

			if (list.return_name != null)
			{
				// if (symbol_lookup_key(locals, list.return_name, null) == null)
				if (!localsList.contains(list.return_name))
				{
					LocalsData local = new LocalsData();

					local.id = text_insert_string(list.return_name);
					symbol_insert_symbol(locals, local);
					localsList.add(list.return_name);

					text_printf("  " + list.production.return_type);
					for (int temp_int = 0; temp_int < list.production.return_type_stars; temp_int++)
					{
						text_printf("*");
					}
					text_printf(" " + list.return_name + ";\n");
				}
			}
			list = list.next;
		}
	}

	private void rdp_print_parser_alternate(RdpData production, RdpData primary)
	{
		RdpList list = production.list;
		if (list.next == null)
		{
			rdp_print_parser_sequence(list.production, primary);
		}
		else
		{
			while (list != null)
			{
				if (list.production.kind != K_SEQUENCE)
				{
					text_message(TEXT_FATAL, "internal error - expecting alternate\n");
				}

				indent();

				text_printf("if (");
				rdp_print_parser_test(list.production.id, list.production.first, null);
				text_printf(")\n");
				indent();
				text_printf("{\n");
				rdp_indentation++;

				rdp_print_parser_sequence(list.production, primary);

				rdp_indentation--;
				indent();

				text_printf("}\n");

				if ((list = list.next) != null)
				{
					indent();
					text_printf("else\n");
				}
				else
				/* tail test at end of alternates */
				if (!(production.contains_null && production.lo != 0))
				{
					indent();
					text_printf("else\n");
					rdp_indentation++;
					indent();
					rdp_print_parser_test(production.id, production.first, text_get_string(primary.id));
					rdp_indentation--;
					indent();
					text_printf(";\n");
				}
			}
		}
	}

	private void rdp_print_parser_args(RdpArgList p)
	{
		if (p.next != null)
		{
			rdp_print_parser_args(p.next);
		}
		switch (p.kind)
		{
		case ARG_BOOLEAN:
			text_printf("  arg_boolean(\'" + p.key + "\', \"" + p.desc + "\", &" + p.var + ");\n");
			break;
		case ARG_NUMERIC:
			text_printf("  arg_numeric(\'" + p.key + "\', \"" + p.desc + "\", &" + p.var + ");\n");
			break;
		case ARG_STRING:
			text_printf("  arg_string (\'" + p.key + "\', \"" + p.desc + "\", &" + p.var + ");\n");
			break;
		case ARG_BLANK:
			text_printf("  arg_message(\"" + p.desc + "\");\n");
			break;
		}
	}

	private void rdp_print_parser_include_line(RdpStringList p)
	{
		if (p.next != null)
		{
			rdp_print_parser_include_line(p.next);
		}
		text_printf("#include \"" + p.str1 + "\"\n");
	}

	private void rdp_print_parser_item(RdpData prod, RdpData primary, String return_name, RdpParamList actuals,
			int promote_epsilon, int promote, String default_action)
	{
		if (promote == PROMOTE_DEFAULT)
		{
			promote = prod.promote_default;
		}

		if (!(prod.kind == K_CODE && prod.code_successor != 0))
		{
			indent(); /* Don't indent code sequence-internal or inline items */
		}

		switch (prod.kind)
		{
		case K_INTEGER:
		case K_REAL:
		case K_STRING:
		case K_EXTENDED:
		case K_TOKEN:
			if (rdp_dir_tree != 0)
			{
				if (promote == PROMOTE_DONT)
				{
					/* add a tree node for this scanner item as child of current parent */
					text_printf("if (rdp_tree_update) rdp_add_child(NULL, rdp_tree);\n");
					indent();
				}
				else if (promote == PROMOTE_AND_COPY)
				{
					/* copy scanner data to current tree parent */
					text_printf("if (rdp_tree_update) memcpy(rdp_tree, text_scan_data, sizeof(scan_data));\n");
					indent();
				}
				else if (promote == PROMOTE_ABOVE)
				{
					/* add a tree node for this scanner item as parent of current parent */
					text_printf("if (rdp_tree_update) rdp_add_parent(NULL, rdp_tree);\n");
					indent();
				}
			}
			text_printf("scan_test("
					+ (rdp_error_production_name.value() ? "\"" + text_get_string(primary.id) + "\"" : "NULL") + ", ");
			rdp_print_parser_production_name(prod);
			text_printf(", &" + text_get_string(primary.id) + "_stop);\n");
			indent();
			/* disable if -p option used */
			if (return_name != null && !rdp_parser_only.value())
			{
				text_printf(return_name + " = SCAN_CAST->"
						+ (prod.kind == K_REAL ? "data.r" : prod.kind == K_INTEGER ? "data.i" : "id") + ";\n");
				indent();
			}
			text_printf("scan_();\n");
			break;
		case K_CODE:
			if (!rdp_parser_only.value()) /* disabled by -p option */
			{
				if (prod.code_pass != 0)
				{
					text_printf("if (rdp_pass == " + prod.code_pass + ") { \\\n");
				}
				String temp = text_get_string(prod.id);
				for (char ch : temp.toCharArray())
				{
					if (ch == '\n')
					{
						text_printf("\\\n");
					}
					else if (isprint(ch))
					{
						text_printf("" + ch);
					}
				}

				if (prod.code_pass != 0)
				{
					text_printf(" \\\n}");
				}

				if (prod.kind == K_CODE && prod.code_terminator != 0)
				{
					text_printf("\n"); /* terminate semantic actions tidily */
				}
			}
			break;
		case K_PRIMARY:
			if (rdp_dir_tree != 0 && promote == PROMOTE_AND_COPY)
			{
				text_printf("if(rdp_tree_update) {rdp_tree.id = \"" + text_get_string(prod.id)
						+ "\"; rdp_tree.token = 0;}\n");
			}
			if (return_name != null && !rdp_parser_only.value())
			{
				text_printf(return_name + " = ");
			}
			text_printf(text_get_string(prod.id));
			if (prod.code_only == 0 && actuals == null)
			{
				rdp_print_parser_param_list(promote == PROMOTE_DONT ? text_get_string(prod.id) : null, actuals, 0, 0);
			}
			text_printf(";\n");
			break;
		case K_SEQUENCE:
			text_message(TEXT_FATAL, "internal error - unexpected alternate in sequence\n");
			break;
		case K_LIST:
			rdp_print_parser_subproduction(prod, primary, promote_epsilon, default_action);
			break;
		default:
			text_message(TEXT_FATAL, "internal error - unexpected kind found\n");
		}
	}

	private void rdp_print_parser_param_list(String first, RdpParamList params, int definition, int start_rule)
	{
		text_printf("(");

		/* processing for tree parameter */
		if (rdp_dir_tree != 0)
		{
			if (definition != 0)
			{
				text_printf("rdp_tree_node_data* rdp_tree");
			}
			else
			{
				if (first == null)
				{
					text_printf("rdp_tree");
				}
				else
				{
					text_printf((start_rule != 0 ? "rdp_tree_root = " : "") + "rdp_add_"
							+ (start_rule != 0 ? "node" : "child") + "(\"" + first + "\", rdp_tree)");
				}
			}

			if (params != null)
			{
				text_printf(", "); /* put in separator for rest of parameters */
			}
		}

		if (params == null && definition != 0 && rdp_dir_tree == 0)
		{
			text_printf("void");
		}
		else
		{
			rdp_print_parser_param_list_sub(params, 1, definition);
		}

		text_printf(")");
	}

	private void rdp_print_parser_param_list_sub(RdpParamList param, int last, int definition)
	{
		if (param != null)
		{
			rdp_print_parser_param_list_sub(param.next, 0, definition);
			text_printf(definition != 0 ? param.type : "");

			if (definition != 0)
			{
				for (int count = 0; count < param.stars; count++)
				{
					text_printf("*");
				}
			}

			text_printf(definition != 0 ? " " : "");
			switch (param.flavour)
			{
			case PARAM_INTEGER:
				text_printf(Integer.toString(param.n));
				break;
			case PARAM_REAL:
				text_printf(Double.toString(param.r));
				break;
			case PARAM_STRING:
				text_printf("\"" + param.id + "\"");
				break;
			case PARAM_ID:
				text_printf(param.id);
				break;
			}
			text_printf(last != 0 ? "" : ", ");
		}
	}

	private void rdp_print_parser_primaries(SymbolScopeData base)
	{
		RdpData temp = (RdpData) base.nextSymbolInScope();

		text_printf("\n/* Parser functions */\n");
		while (temp != null)
		{
			if (temp.kind == K_PRIMARY && temp.call_count > 0 && temp.code_only == 0)
			{
				boolean is_void = temp.return_type.equals("void") && temp.return_type_stars == 0;
				SymbolScopeData local_scope = symbol_new_scope(locals, text_get_string(temp.id));

				if (temp != rdp_start_prod)
				{
					text_printf("static ");
				}

				text_printf(temp.return_type);

				for (int count = 0; count < temp.return_type_stars; count++)
				{
					text_printf("*");
				}
				text_printf(" " + text_get_string(temp.id));

				rdp_print_parser_param_list(null, temp.params, 1, 0);

				text_printf("\n{\n");

				if (temp.ll1_violation != 0)
				{
					text_printf("/* WARNING - an LL(1) violation was detected at this point in the grammar */\n");
				}

				/* scan all subproductions and add return variables to symbol_ table */
				if (!is_void)
				{
					text_printf("  " + temp.return_type);
					for (int temp_int = 0; temp_int < temp.return_type_stars; temp_int++)
					{
						text_printf("*");
					}
					text_printf(" result;\n");
					temp.locals.add("result");
				}

				if (!rdp_parser_only.value())
				{
					rdp_print_locals(temp, temp.locals);
				}
				local_scope.unlinkScope();

				/* In trace mode, add an entry message */
				if (rdp_trace.value())
				{
					text_printf("  text_message(TEXT_INFO, \"Entered \'" + text_get_string(temp.id) + "\'\\n\");\n\n");
				}
				text_printf("  {\n");
				rdp_indentation = 2;

				rdp_print_parser_alternate(temp, temp);

				/* add error handling on exit */
				text_printf("    scan_test_set("
						+ (rdp_error_production_name.value() ? "\"" + text_get_string(temp.id) + "\"" : "NULL") + ", &"
						+ text_get_string(temp.id) + "_stop, &" + text_get_string(temp.id) + "_stop);\n");
				text_printf("   }\n");
				/* In trace mode, add an exit message */
				if (rdp_trace.value())
				{
					text_printf("  text_message(TEXT_INFO, \"Exited  \'" + text_get_string(temp.id) + "\'\\n\");\n");
				}

				text_printf((is_void ? "" : "  return result;\n") + "}\n\n");
			}
			temp = (RdpData) temp.nextSymbolInScope();
		}
	}

	private void rdp_print_parser_sequence(RdpData production, RdpData primary)
	{
		RdpList list = production.list;

		while (list != null)
		{
			rdp_print_parser_item(list.production, primary, list.return_name, list.actuals, list.promote_epsilon,
					list.promote, list.default_action);
			list = list.next;
		}
	}

	private void rdp_print_parser_string(String string)
	{
		for (char ch : string.toCharArray())
		{
			if (ch == '\"' || ch == '\\' || ch == '\'')
			{
				text_printf("\\");
			}
			text_printf("" + ch);
		}
	}

	private void rdp_print_parser_subproduction(RdpData prod, RdpData primary, int promote_epsilon,
			String default_action)
	{
		if (prod.lo == 0) /* this can be an optional body */
		{
			text_printf("if (");
			rdp_print_parser_test(prod.id, prod.first, null);
			text_printf(")\n");
			indent();
		}

		text_printf("{ /* Start of " + text_get_string(prod.id) + " */\n");

		if (prod.ll1_violation != 0)
		{
			indent();
			text_printf("/* WARNING - an LL(1) violation was detected at this point in the grammar */\n");
		}

		rdp_indentation++;

		/* We don't need to instantiate count if hi is infinity and lo is 0 or 1 */
		if (!((prod.hi == 0 || prod.hi == 1) && (prod.lo == 1 || prod.lo == 0)))
		{
			indent();
			text_printf("unsigned long rdp_count = 0;\n");
		}

		indent();
		text_printf("while (1)\n");

		indent();
		text_printf("{\n");
		rdp_indentation++;

		/* Put in test that first element of body matches if iterator low count > 0 and prod isn't nullable */
		if (prod.lo != 0 && !prod.contains_null)
		{
			indent();
			rdp_print_parser_test(prod.id, prod.first, text_get_string(primary.id));
			text_printf(";\n");
		}

		indent();
		text_printf("{\n");
		rdp_indentation++;

		rdp_print_parser_alternate(prod, primary);

		indent();
		text_printf("}\n");
		rdp_indentation--;

		if (!((prod.hi == 0 || prod.hi == 1) && (prod.lo == 1 || prod.lo == 0)))
		{
			indent();
			text_printf("rdp_count++;\n");
		}

		if (prod.hi > 1) /* Don't bother testing rdp_count of hi is zero or infty */
		{
			indent();
			text_printf("if (rdp_count == " + prod.hi + ") break;\n");
		}

		if (prod.supplementary_token != null)
		{
			indent();
			text_printf(
					"if (SCAN_CAST->token != " + text_get_string(prod.supplementary_token.token_enum) + ") break;\n");

			if (rdp_dir_tree != 0)
			{
				if (prod.delimiter_promote == PROMOTE_DONT)
				{
					/* add a tree node for this scanner item */
					text_printf("if (rdp_tree_update) rdp_add_child(NULL, rdp_tree);\n");
					indent();
				}
				else if (prod.delimiter_promote == PROMOTE_AND_COPY)
				{
					/* copy scanner data to current tree parent */
					text_printf("if (rdp_tree_update) memcpy(rdp_tree, text_scan_data, sizeof(scan_data));\n");
					indent();
				}
			}

			indent();
			text_printf("scan_();\n"); /* skip list token */
		}
		else if (prod.hi != 1)
		{
			indent();
			text_printf("if (!");
			rdp_print_parser_test(prod.id, prod.first, null);
			text_printf(") break;\n");
		}

		if (prod.hi == 1)
		{
			indent();
			text_printf("break;   /* hi limit is 1! */\n");
		}

		rdp_indentation--;
		indent();
		text_printf("}\n");

		if (prod.lo > 1) /* test rdp_count on way out */
		{
			indent();
			text_printf("if (rdp_count < " + prod.lo + ")");
			text_printf("  text_message(TEXT_ERROR_ECHO, \"iteration count too low\\n\");\n");
		}

		rdp_indentation--;
		indent();
		text_printf("} /* end of " + text_get_string(prod.id) + " */\n");

		if (prod.lo == 0 && (rdp_dir_tree != 0 || default_action != null))
		{
			indent();
			text_printf("else\n");
			indent();
			text_printf("{\n");
			rdp_indentation++;
			indent();
			text_printf("/* default action processing for " + text_get_string(prod.id) + "*/\n");
			if (rdp_dir_tree != 0)
			{
				/* First do tree node handling */
				if (promote_epsilon == PROMOTE_DONT)
				{
					/* add an epsilon tree node */
					indent();
					if (rdp_dir_annotated_epsilon_tree != 0)
					{
						text_printf(
								"if (rdp_tree_update) {rdp_tree_node_data *temp = rdp_add_child(NULL, rdp_tree); temp->id = \"#: "
										+ text_get_string(prod.id + 4) + "\"; temp.token = SCAN_P_ID;}\n");
					}
					else
					{
						text_printf(
								"if (rdp_tree_update) {rdp_tree_node_data *temp = rdp_add_child(NULL, rdp_tree); temp->id = NULL; temp->token = SCAN_P_ID;}\n");
					}
				}
				else if (promote_epsilon == PROMOTE_AND_COPY)
				{
					/* copy epsilon to current tree parent */
					indent();
					if (rdp_dir_annotated_epsilon_tree != 0)
					{
						text_printf("if (rdp_tree_update) {rdp_tree->id = \"#: " + text_get_string(prod.id + 4)
								+ "\"; rdp_tree.token = SCAN_P_ID;}\n");
					}
					else
					{
						text_printf("if (rdp_tree_update) {rdp_tree->id = NULL; rdp_tree->token = SCAN_P_ID;}\n");
					}
				}
			}

			/* Now copy out default action */
			/* disabled by -p option */
			if (!rdp_parser_only.value() && default_action != null)
			{
				for (char ch : default_action.toCharArray())
				{
					if (ch == '\n')
					{
						text_printf(" \\\n");
					}
					else
					{
						text_printf("" + ch);
					}
				}
				text_printf("\n"); /* terminate semantic actions tidily */
			}
			rdp_indentation--;
			indent();
			text_printf("}\n");
		}
	}

	private void rdp_print_parser_test(int first_name, Set first, String follow_name)
	{
		text_printf("scan_test");

		switch (set_cardinality(first))
		{
		default:
			text_printf(
					"_set(" + (rdp_error_production_name.value() ? "\"" + text_get_string(first_name) + "\"" : "NULL")
							+ ", &" + text_get_string(first_name) + "_first");
			break;
		case 1:
			text_printf("(" + (rdp_error_production_name.value() ? "\"" + text_get_string(first_name) + "\"" : "NULL")
					+ ", ");
			first.print(rdp_enum_string, 78);
			break;
		case 0:
			System.err.println("Set " + first + " is empty");
		}

		if (follow_name == null)
		{
			text_printf(", NULL)");
		}
		else
		{
			text_printf(", &" + follow_name + "_stop)");
		}
	}
}
