package org.borium.rdp;

import static org.borium.rdp.Arg.ArgKind.*;
import static org.borium.rdp.RDP.*;
import static org.borium.rdp.RdpGram.*;
import static org.borium.rdp.Scan.*;
import static org.borium.rdp.Symbol.*;
import static org.borium.rdp.Text.*;
import static org.borium.rdp.Text.TextMessageType.*;

import org.borium.rdp.Arg.*;

public class RdpAux
{
	static class RdpParamList
	{
		String id;
		int n;
		double r;
		String type;
		int stars;
		RdpParamType flavour;
		RdpParamList next;
	}

	private static class RdpArgList
	{
		@SuppressWarnings("unused")
		ArgKind kind;
		@SuppressWarnings("unused")
		String var;
		@SuppressWarnings("unused")
		String key;
		@SuppressWarnings("unused")
		String desc;
		@SuppressWarnings("unused")
		RdpArgList next;
	}

	private static class RdpData extends Symbol
	{
		@SuppressWarnings("unused")
		int token;
		/** token value for tokens */
		@SuppressWarnings("unused")
		int token_value;
		/** extended value for tokens */
		@SuppressWarnings("unused")
		int extended_value;
		@SuppressWarnings("unused")
		int kind;
		/** return_type name */
		@SuppressWarnings("unused")
		String return_type;
		/** number of indirections in return type */
		@SuppressWarnings("unused")
		int return_type_stars;
		/** pointer to token value as a string */
		@SuppressWarnings("unused")
		int token_string;
		/** pointer to token value as enum element */
		@SuppressWarnings("unused")
		int token_enum;
		/** pointer to extended value as enum element */
		@SuppressWarnings("unused")
		String extended_enum;
		/** default promotion operator */
		@SuppressWarnings("unused")
		int promote_default;
		/** promotion operator for inline calls */
		@SuppressWarnings("unused")
		int promote;
		/** promotion operator for iterator delimiters */
		@SuppressWarnings("unused")
		int delimiter_promote;
		/**
		 * flag to suppress unused production warning if production contains only comments
		 */
		@SuppressWarnings("unused")
		boolean comment_only;
		/** for quick first calculation */
		@SuppressWarnings("unused")
		boolean contains_null;
		/** production has inherited attributes */
		@SuppressWarnings("unused")
		boolean parameterised;
		/** mark items that follow a code item */
		@SuppressWarnings("unused")
		int code_successor;
		/** mark last code item in sequence */
		@SuppressWarnings("unused")
		int code_terminator;
		/** primary production with code only */
		@SuppressWarnings("unused")
		int code_only;
		/** has appeared on LHS of ::= */
		@SuppressWarnings("unused")
		int been_defined;
		/** production being checked flag */
		@SuppressWarnings("unused")
		int in_use;
		/** ll(1) violation detected */
		@SuppressWarnings("unused")
		int ll1_violation;
		/** first() completed on this production */
		@SuppressWarnings("unused")
		int first_done;
		/** follow() completed on this production */
		@SuppressWarnings("unused")
		int follow_done;
		/** set of first symbols */
		@SuppressWarnings("unused")
		final Set first = new Set();
		/** how many times production is called */
		@SuppressWarnings("unused")
		int call_count;
		/** number of elements in first set */
		@SuppressWarnings("unused")
		int first_cardinality;
		/** set of follow symbols */
		final Set follow = new Set();
		/** number of elements in follow set */
		@SuppressWarnings("unused")
		int follow_cardinality;
		/** active parser pass for code element */
		@SuppressWarnings("unused")
		int code_pass;
		/** minimum iteration count */
		@SuppressWarnings("unused")
		int lo;
		/** maximum iteration count */
		@SuppressWarnings("unused")
		int hi;
		/** list of parameter names (and types) */
		@SuppressWarnings("unused")
		RdpParamList params;
		/** list of actuals filled in by item_ret */
		@SuppressWarnings("unused")
		RdpParamList actuals;
		/** list of alternatives or items */
		@SuppressWarnings("unused")
		RdpList list;
		/** spare token pointer */
		@SuppressWarnings("unused")
		RdpData supplementary_token;
		/** extended keyword close string */
		@SuppressWarnings("unused")
		String close;
	}

	private static class RdpList
	{
		@SuppressWarnings("unused")
		String return_name;
		@SuppressWarnings("unused")
		RdpData production;
		/** list of actuals used by production call */
		@SuppressWarnings("unused")
		RdpParamList actuals;
		@SuppressWarnings("unused")
		RdpList next;
		/** promotion operator for this node */
		@SuppressWarnings("unused")
		int promote;
		/** promotion operator for epsilons generated by this node */
		@SuppressWarnings("unused")
		int promote_epsilon;
		/** action to be executed of lo=0 and body not taken */
		@SuppressWarnings("unused")
		String default_action;
	}

	private enum RdpParamType
	{
		PARAM_ID, PARAM_STRING, PARAM_REAL, PARAM_INTEGER
	}

	private static final int K_EXTENDED = 0;
	private static final int K_INTEGER = 1;
	private static final int K_REAL = 2;
	private static final int K_STRING = 3;
	private static final int K_CODE = 4;
	private static final int K_TOKEN = 5;
	private static final int K_PRIMARY = 6;
	private static final int K_SEQUENCE = 7;
	private static final int K_LIST = 8;

	private static final int RDP_OLD = 0;
	private static final int RDP_NEW = 1;
	private static final int RDP_ANY = 2;

	/** force output files flag */
	public static Pointer<Boolean> rdp_force = new Pointer<>(false);

	/** flag to force writing of production name into error messages */
	public static Pointer<Boolean> rdp_error_production_name = new Pointer<>(false);

	/** flag to generate expanded bnf listing */
	public static Pointer<Boolean> rdp_expanded = new Pointer<>(false);

	/** omit semantic actions flag */
	public static Pointer<Boolean> rdp_parser_only = new Pointer<>(false);

	/** add trace messages flag */
	public static Pointer<Boolean> rdp_trace = new Pointer<>(false);

	/** symbol table for the parser */
	@SuppressWarnings("unused")
	private static SymbolScopeData rdp_base;

	/** string from OUTPUT_FILE directive */
	@SuppressWarnings("unused")
	private static String rdp_dir_output_file = null;

	private static Set rdp_production_set = new Set();

	/** data from ARG_* directives */
	static RdpArgList rdp_dir_args = null;

	/** convert symbols flag */
	private static boolean rdp_undeclared_symbols_are_tokens;

	static void rdp_pre_parse()
	{
		rdp_dir_output_file = text_force_filetype(rdp_sourcefilename, "out");
		rdp_base = symbol_new_scope(rdp, "parser");
		rdp_production_set.assignList(K_PRIMARY, K_SEQUENCE, K_LIST);

		rdp_add_arg(ARG_BLANK, null, null, "");
		rdp_add_arg(ARG_BOOLEAN, "f", "rdp_filter", "Filter mode (read from stdin and write to stdout)");
		rdp_add_arg(ARG_BOOLEAN, "l", "rdp_line_echo", "Make a listing");
		rdp_add_arg(ARG_BOOLEAN, "L", "rdp_lexicalise", "Print lexicalised source file");
		rdp_add_arg(ARG_STRING, "o", "rdp_outputfilename", "Write output to filename");
		rdp_add_arg(ARG_BOOLEAN, "s", "rdp_symbol_echo", "Echo each scanner symbol as it is read");
		rdp_add_arg(ARG_BOOLEAN, "S", "rdp_symbol_statistics", "Print summary symbol table statistics");
		rdp_add_arg(ARG_NUMERIC, "t", "rdp_tabwidth", "Tab expansion width (default 8)");
		rdp_add_arg(ARG_NUMERIC, "T", "rdp_textsize", "Text buffer size in bytes for scanner (default 20000)");
		rdp_add_arg(ARG_BOOLEAN, "v", "rdp_verbose", "Set verbose mode");
		rdp_add_arg(ARG_STRING, "V", "rdp_vcg_filename", "Write derivation tree to filename in VCG format");

		/* add predefined primitive productions */
		rdp_find("ID", K_STRING, RDP_ANY).token_value = SCAN_P_ID;
		rdp_find("INTEGER", K_INTEGER, RDP_ANY).token_value = SCAN_P_INTEGER;
		rdp_find("REAL", K_REAL, RDP_ANY).token_value = SCAN_P_REAL;
		rdp_find("EOLN", K_STRING, RDP_ANY).token_value = SCAN_P_EOLN;
	}

	private static void rdp_add_arg(ArgKind kind, String key, String var, String desc)
	{
		RdpArgList temp = new RdpArgList();

		temp.kind = kind;
		temp.key = key;
		temp.var = var;
		temp.desc = desc;
		temp.next = rdp_dir_args;
		rdp_dir_args = temp;
	}

	private static RdpData rdp_find(String id, int kind, int symbol)
	{
		SymbolTable table;
		// Figure out which table to use
		switch (kind)
		{
		case K_CODE:
			table = codes;
			break;
		case K_TOKEN:
		case K_EXTENDED:
			table = tokens;
			break;
		default:
			table = rdp;
		}
		RdpData temp = null;
		if ((temp = (RdpData) symbol_lookup_key(table, id, null)) == null)
		{
			if (symbol == RDP_OLD && rdp_undeclared_symbols_are_tokens)
			{
				text_message(TEXT_WARNING_ECHO, "Undeclared symbol \'" + id + "\' converted to token\n");
				rdp_process_token(id);
			}
			else
			{
				if (symbol == RDP_OLD)
				{
					text_message(TEXT_ERROR_ECHO, "Undeclared symbol \'" + id + "\'\n");
				}
				temp = new RdpData();
				temp.id = text_insert_string(id);
				symbol_insert_symbol(table, temp);
				temp.token = SCAN_P_ID;
				temp.kind = kind;
				temp.hi = temp.lo = 1; /* set instance numbers to one */
				temp.first_cardinality = 0;
				temp.follow.assign(SCAN_P_EOF);
				temp.follow_cardinality = 1;
				temp.return_type_stars = 0;
				switch (kind)
				{
				case K_INTEGER:
					temp.return_type = "long int";
					break;
				case K_REAL:
					temp.return_type = "double";
					break;
				case K_TOKEN:
				case K_STRING:
					temp.return_type = "char";
					temp.return_type_stars = 1;
					break;
				default:
					temp.return_type = "void";
				}
			}
		}
		else if (symbol == RDP_NEW)
		{
			text_message(TEXT_ERROR_ECHO, "Doubly declared symbol \'" + id + "\'\n");
		}
		return temp;
	}

	private static RdpData rdp_process_token(String name)
	{
		rdp_check_token_valid(name);
		RdpData result = rdp_find(name, K_TOKEN, RDP_ANY);
		result.call_count++;

		return result;
	}
}
